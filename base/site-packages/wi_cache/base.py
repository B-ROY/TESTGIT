#encoding = utf-8

import sys
import collections
import functools
import hashlib
import logging

from django.conf import settings
from django.core.cache import parse_backend_uri
from django.db import models
from django.db.models import signals
from django.db.models.sql import query
from django.utils import encoding, translation
from django.contrib.auth.models import UserManager
from django.db import models
from django.db.models.query import QuerySet, EmptyQuerySet, insert_query, RawQuerySet
from django.utils.encoding import smart_str
from mongoengine.queryset import  QuerySetManager
from util.cache import func_cache as model_cache, page_cache, fragment_cache , user_cache

try:
    import cjson as json

    json.loads = json.decode
    json.dumps = json.encode
except:
    import json

class NullHandler(logging.Handler):
    """
     log handler  this is no use now
     """

    def emit(self, record):
        pass


def cache_key(klass, _id):
    """
         produce the key
         the formation of the key is object:Class:id
         param:
             _id:type is integer
         return:
             key:string
     """
    return smart_str("o:%s:%s" % (klass.__name__, _id))


class CachingManager(models.Manager):
    """
     Caching Manager,for manager objects.get or .filter(*args,**kwargs)
     class Zomg( models.Model):
         val = models.IntegerField()
         objects = caching.base.UserCachingManager()
     """

    def contribute_to_class(self, cls, name):
        """
          overwrite Base，added Save，Delete Callback
          """
        signals.post_save.connect(self.post_save, sender=cls)
        signals.post_delete.connect(self.post_delete, sender=cls)
        return super(CachingManager, self).contribute_to_class(cls, name)

    def post_save(self, instance, **kwargs):
        """
          invalidate the object that already saved
          param:
              instance:the instance of Object
          """
        self.invalidate(instance)

    def post_delete(self, instance, **kwargs):
        """
          invalidate the object that already deleted
          param:
              instance:the instance of Object
          """
        self.invalidate(instance)

    def invalidate(self, instance):
        """
          update the instance of Object
          """
        key = cache_key(instance.__class__, instance.pk)
        try:
            model_cache.delete(key)
        except Exception, e:
                logging.error(e)
            
        key = cache_key(instance.__class__, instance.appkey)
        try:
            model_cache.delete(key)
        except Exception, e:
                logging.error(e)


    def get(self, *args, **kwargs):
        """ overwrite the get of django
              only cache id == ?
          """
        _id = None
        if len(kwargs) == 1 and len(args) == 0:
            _id = kwargs.get("id") or kwargs.get("appkey") or kwargs.get("pk") or\
                  kwargs.get("app__id") or kwargs.get('channelid')or kwargs.get('name') or \
                  kwargs.get('pid')
            if _id:
                key = cache_key(self.model, _id)
                try:
                    m = model_cache.get(key)
                    if m:
                        logging.debug("get %s from cache" % key)
                        return m
                except Exception, e:
                    print e

        model = super(CachingManager, self).get(*args, **kwargs)
        if _id:
            try:
                if model:
                    timeout = kwargs.get("_timeout_", 60 * 60) #1hour
                    model_cache.set(key, model, timeout)
            except Exception, e:
                logging.error(e)

        return model


    def get_multi(self, *args, **kwargs):

        app_ids = kwargs.get('id__in', [])

        if app_ids:
            cache_ids = []
            cache_keys = [cache_key(self.model, app_id) for app_id in app_ids]
            try:
                #get data from cache
                cache_data = model_cache.get_multi(cache_keys)
                cache_ids = [int(key.split(":")[2]) for key in cache_data.keys()]
            except Exception, e:
                logging.debug('get from memcache failed: %s', e)

            query_ids = set(app_ids) - set(cache_ids)

            if query_ids:
                db_data = super(CachingManager, self).filter(id__in=query_ids)
                try:
                    expires = kwargs.get("expires", 60 * 60)
                    key_map = {}
                    for item in db_data:
                        key_map[cache_key(self.model, item.id)] = item

                    model_cache.set_multi(key_map, time=expires)

                    results = cache_data.values() + list(db_data)
                    results.sort(key=lambda x: app_ids.index(x.id))
                    return results

                except Exception, e:
                    logging.error(e)
            else:
                results = cache_data.values()
                results.sort(key=lambda x: app_ids.index(x.id))
                return results
        else:
            return []




class UserCachingManager(models.Manager):
    """
     Caching Manager,for manager objects.get or .filter(*args,**kwargs)
     class Zomg( models.Model):
         val = models.IntegerField()
         objects = caching.base.UserCachingManager()
     """

    def contribute_to_class(self, cls, name):
        """
          overwrite Base，added Save，Delete Callback
          """
        signals.post_save.connect(self.post_save, sender=cls)
        signals.post_delete.connect(self.post_delete, sender=cls)
        return super(UserCachingManager, self).contribute_to_class(cls, name)

    def post_save(self, instance, **kwargs):
        """
          invalidate the object that already saved
          param:
              instance:the instance of Object
          """
        self.invalidate(instance)

    def post_delete(self, instance, **kwargs):
        """
          invalidate the object that already deleted
          param:
              instance:the instance of Object
          """
        self.invalidate(instance)

    def invalidate(self, instance):
        """
          update the instance of Object
          """
        key = cache_key(instance.__class__, instance.pk)
        try:
            user_cache.delete(key)
        except Exception, e:
            logging.error(e)

    def get(self, *args, **kwargs):
        """ overwrite the get of django
              only cache id == ?
          """
        _id = None
        if len(kwargs) == 1 and len(args) == 0:
            _id = kwargs.get("id") or kwargs.get("appkey") or kwargs.get("pk") or kwargs.get("key") or kwargs.get(
                "app__id")
            if _id:
                key = cache_key(self.model, _id)
                try:
                    m = user_cache.get(key)
                    if m:
                        logging.debug("get %s from cache" % key)
                        return m
                except Exception, e:
                    logging.error(e)

        model = super(UserCachingManager, self).get(*args, **kwargs)
        if _id:
            try:
                if model:
                    timeout = kwargs.get("_timeout_", 60 * 60) #1hour
                    user_cache.set(key, model, timeout)
            except Exception, e:
                print e

        return model