#encoding = utf-8
import sys, os
from django.core.cache import cache as mclient
from django.conf import settings
from django.template import Library
from django.core.cache import cache, parse_backend_uri
from django.utils import encoding
from django.http import HttpResponse
import logging, datetime
import json
# from pymongo.json_util import *
from wicache import *


mclient = model_cache
pclient = page_cache

def func_cache_key(cache_key, *a, **kw):
	""" generate function cache_key """
	mkey = cache_key
	keys = ""
	for i in a:
		if (isinstance(i, basestring) or isinstance(i, int) or isinstance(i,long) or isinstance(i,float)):
			keys += ":%s" % str(i)
		elif hasattr(i, "id"):
			keys += ":%s" % str(getattr(i, "id"))
	for k, v in kw.iteritems():
		if (isinstance(v, basestring) or isinstance(v, int) or isinstance(i,long) or isinstance(i,float)):
			keys += "%s:%s" % (str(k), str(v))
		elif hasattr(v, "id"):
			keys += "%s:%s" % (k, str(getattr(v, "id")))
	mkey += keys
	return mkey


def expire_func_cache(cache_key, *a, **kw):
	""" expire function cache by cache_key """
	key = func_cache_key(cache_key, *a, **kw)
	mclient.delete(key)


def func_cache(cache_key, timeout=1800, cache_first_page=False):
	"""
	function cache for classmethod
	param:
		cache_key: the key of cache in logging type is string
		timeout:the deadline of cache  default is 1800
		cache_first_page = (True,False)
	"""

	def _func(func):
		def wrap(*a, **kw):
			if cache_first_page:
				if kw.get("page", 1) != 1:
					return func(*a, **kw)
				if kw.get("start", 0) != 0:
					return func(*a, **kw)

			data = None
			mkey = func_cache_key(cache_key, *a[1:], **kw)
			try:
				data = mclient.get(mkey)
				if not data:
					data = func(*a, **kw)
					if data:
						mclient.set(mkey, data, timeout)
					#print mkey,"get from db"
				else:
					#print mkey,"get from cache"
					pass
				return data
			except Exception, e:
				print e
				if data:
					return data
				else:
					return "<error>%s</error>" % e

		return wrap

	return _func


def expire_page_cache(key):
	mclient.delete(str(key))


def in_page_cache(key, obj):
	data = mclient.get(str(key))
	if data:
		for d in data:
			if d.id == obj.id:
				return True
	return False


def func_page_cache(cache_key, timeout=1800, cache_first_page=False):
	"""
	function cache for classmethod
	param:
		cache_key: the key of cache in logging type is string
		timeout:the deadline of cache  default is 1800
		cache_first_page = (True,False)
	"""

	def _func(func):
		def wrap(*a, **kw):
			if cache_first_page:
				if kw.get("page", 1) != 1:
					return func(*a, **kw)
				if kw.get("start", 0) != 0:
					return func(*a, **kw)

			data = None
			mkey = str(func_cache_key(cache_key, *a[1:], **kw))
			#print mkey
			try:
				data = mclient.get(mkey)
				context = mclient.get(str(mkey + ":context"))
				if not data or not context:
					context, data = func(*a, **kw)
					if data:
						sets = []
						for d in data:
							sets.append(d)
						mclient.set(mkey, sets, timeout)
						mclient.set(str(mkey + ":context"), context)
					#print mkey, "get from db"
				else:
					#print mkey, "get from cache"
					pass
				return context, data
			except Exception, e:
				print "cache error:", e
				if data:
					return context, data
				else:
					return "<error>%s</error>" % e

		return wrap

	return _func


def func_models_cache(cache_key, timeout=1800, cache_first_page=False):
	"""
	function cache for instance method
	param:
		cache_key: the key of cache in logging type is string
		timeout:the deadline of cache  default is 1800
		cache_first_page = (True,False)
	"""

	def _func(func):
		def wrap(obj, *a, **kw):
			if cache_first_page:
				if kw.get("page", 1) != 1:
					return func(*a, **kw)

			data = None
			key = func_cache_key(cache_key, *a, **kw)
			key += ":%s" % str(obj.id)

			#print key
			try:
				data = mclient.get(key)
			except Exception, e:
				print e

			if not data:
				data = func(obj, *a, **kw)
				try:
					if data:
						mclient.set(key, data, timeout)
				except Exception, e:
					print e
			return data

		return wrap

	return _func


def expire_func_models_cache(cache_key, obj, *a, **kw):
	try:
		""" expire function cache by cache_key """
		key = func_cache_key(cache_key, *a, **kw)
		key += ":%s" % str(obj.id)
		#print "expire key" , key
		mclient.delete(key)
	except Exception, e:
		print e


def page_cache(timeout=1800):
	"""
	page cache
	param:
		timeout:the deadline of cache  default is 1800
	"""

	def _func(func):
		def wrap(request, *a, **kw):
			key = request.get_full_path()
			#pass chinese
			try:
				key = mkey.encode("utf-8")
			except Exception, e:
				key = str(key)

			data = None
			try:
				data = mclient.get(key)
				if not data:
					data = func(request, *a, **kw)
					if data:
						mclient.set(key, data, timeout)
				return HttpResponse(data, content_type=request.META.get("CONTENT_TYPE", "text/plain"))
			except Exception, e:
				if data:
					HttpResponse(data, content_type=request.META.get("CONTENT_TYPE", "text/plain"))
				else:
					return HttpResponse("<objects><error>%s</error></objects>" % e,
					                    content_type=request.META.get("CONTENT_TYPE", "text/plain"))

		return wrap

	return _funcs


def api_page_cache(timeout=1800):
	""" tornado web page cache """

	def _func(func):
		def wrap(self, *a, **kw):
			if self.get_argument("page", 1) != 1:
				self.write(func(*a, **kw))
				return
			if self.get_argument("start", 0) != 0:
				self.write(func(*a, **kw))
				return

			data = None
			cache_key = self.request.uri
			try:
				data = pclient.get(cache_key)
				if not data:
					data = func(self, *a, **kw)
					if data:
						if isinstance(data, dict):
							if int(data.get("total_count", 1)) > 0:
								pclient.set(cache_key, data, timeout)
						else:
							pclient.set(cache_key, data, timeout)
				else:
					#print "get from cache", cache_key
					pass

				#write to client
				self.write(data)
			except Exception, e:
				print e
				if data:
					self.write(data)
				else:
					self.write("{'error':'%s'}" % e)

		return wrap

	return _func




